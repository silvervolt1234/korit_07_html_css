/* 자손 결합자 */
.outer li {
  color: olivedrab;
}
/* 
  .outer 공백 li로 되어 있다는 점을 보면 outer 클래스의 자손 요소인 li 태그드레게 color: olivedrab을 적용하는 의미. 그렇기에 ol 요소의 자손 요소인 li들은 여전히 검은색

  Java 때와 달리 자식 클래스 / 서브 클래스라는 표현을 쓰지 않은 이유는

  자식 / 손주 / 증손주 ... 하위 항목들이 전부 다 css 영향을 받기에
  사과 / 포도 / 딸기 / 키위도 olivedrab이 된 점을 확인
*/

.outer > li {
  color: dodgerblue;
}

.outer > li ul {
  text-decoration: underline;
}
/* 
  자손이 아니라 자식(1촌 자손)만 변경하고 싶다면
  >가 포함. 18번 라인의 경우 outer 클래스가 1촌 자식의 자손인 li 태그에 underline이 적용되는 형태

  .outer의 자식인 li의 자식은 ul이라는 점을 감안하면 적용 불가능

  참고 :
  .outer li {color: olivedrab;}을 없앴다고 가정하면, .outer > li {color:dodgerblue}가 자손까지 적용됨.
  이상의 경우는 서체나 텍스트 관련 등 일부 CSS 속성들이 자식들에게 자동 상속되기 때문. 즉 일촌 자식 결합자(>)라도 여기에 적용된 속성이 자동 상속을 지원흔 속성이면 덮어쓰는 다른 선택자와 속성을 지정하지 않으면 자손들도 해당 속성 승계
*/

/* 뒤따르는 모든 동생들 결합자 */
.starter ~ li {
  font-style: italic;
}

/* 뒤따르는 바로 다음 동생 결합자 */
.starter + li {
  font-weight: bold;
}

/* 가상 클래스 */
/* 
  이상까지는 특정 id나 특정 클래스를 선택해서 스타일을 지정했는데 가상 클래스는 특정 상황을 가정하고 이름을 지정. 작성 방식은 콜론(:) 사용
*/

ol li:first-child, ol li:last-child {
  color: yellowgreen;
}

/* ~가 아닌 요소 가상 리스트 */
.outer > li:not(:last-child) {
  text-decoration: line-through;
}

ul:not(.outer) li {
  font-weight: bold;
}
/* 
  52번 라인은 outer의 직계 자식인 li 태그 중 마지막 요소가 아닌걸 골라 line-through를 적용하라는 의미. 그렇기에 직계 자식인 육류, 채소, 유제품, 괴일 중 나머지 세개에만 취소선 적용

  56번 라인은 ul 태그 중 outer 클래스가 아닌 것을 골라서 그 자손인 li 요소인 bold를 적용하라는 의미로 ul태그는 두 개로 중첩되어 이루어져 있기 떄문에 들여쓰기가 적용된 사과, 포도, 딸기, 키위가 포함된 ul은 class="outer"가 아니기에 bold가 적용
*/
/* ~ 번째 요소 가상 클래스 */
/* odd / even / 3n을 3 대신 ()애 넣어보면 결과값이 바뀌는걸 확인 */
ol li:nth-child(3n) {
  font-weight: bold;
  color: deeppink;
}

/* 가상 클래스 개념을 모르더라더 자주 쓰게 되는 예시 */
li:hover {
  font-weight: bold;
  color: blue;
}
/* 마우스 오버 기능을 지원하는 :hover의 경우는 자주 쓰이는 편. 김3의 경우 deeppink에서 안 바뀌는걸 볼 수 있는데 :hover보다 우선도가 높아서(=조직이 구체적) */